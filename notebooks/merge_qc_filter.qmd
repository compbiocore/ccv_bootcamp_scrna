---
title: "Data merging"
format: html
editor: visual
execute: 
  cache: true
---
{{< include seurat_objects.qmd >}}

## Data merging

In addition to `ifnb`, we have also installed `pbmc3k`, which is from 2,700 peripheral blood mononuclear cells (PBMC) from 10X genomics. 

```{r}
?pbmc3k
pbmc3k@assays
head(pbmc3k@meta.data)
```
- Let's merge the datasets to make our QC and filtering a bit smoother.
- `merge()` merges the raw count matrices of two Seurat objects and creates a new Seurat object with the resulting combined raw count matrix. 
- To easily tell which original object any particular cell came from, you can set the `add.cell.ids` parameter with an c(x, y) vector, which will prepend the given identifier to the beginning of each cell name. 
- The original project ID will remain stored in object meta data under `orig.ident`.

```{r "merge"}

all_data <- merge(x = ifnb, y = pbmc3k, add.cell.ids = c("ifnb", "pbmc3k"), project = 'pbmc')

```

## Data QC

- We care about the percentage of reads that map to the mitochondrial genome because high mitochondrial reads in a cell can indicate that the cells are low-quality or dying cells
- The mitochondrial QC metrics are calcualted with the `PercentageFeatureSet()` function, which calculates the percentage of counts originating from a set of features
- We use the set of all genes starting with MT- as a set of mitochondrial genes -- the format of the mt sequences will vary depending on which organism/genome is used...(might be 'mt-' for example).

```{r "Figure out format of MT gene IDs"}
rownames(all_data) %>% grep(pattern = '^mt-', ignore.case = TRUE, value = TRUE)
```

```{r "add mt percent data"}
all_data[["percent.mt"]] <- PercentageFeatureSet(all_data, pattern = "^MT-")
```

- Before we plot, we can set the order of the object idents to whatever order we'd like:
```{r}
Idents(all_data) <- 'orig.ident'
levels(all_data) <- c("pbmc3k", "IMMUNE_CTRL", "IMMUNE_STIM")
```

- We can also look at plots showing the distribution of the `percent.mt`, `nFeature_RNA` and `nCount_RNA`
- `nFeature_RNA` is the number of genes 
- `nCount_RNA` is the number of UMIs (unique molecules -- like counts)

```{r}
VlnPlot(all_data, features = "nFeature_RNA")
```
```{r}
VlnPlot(all_data, features = "nCount_RNA")
```
```{r}
VlnPlot(all_data, features="percent.mt")
```

```{r}
FeatureScatter(all_data, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
```
```{r}
FeatureScatter(all_data, feature1 = "nCount_RNA", feature2 = "percent.mt")
```
```{r}
FeatureScatter(all_data, feature1 = "nFeature_RNA", feature2 = "percent.mt")
```

You can also just use ggplot to make your own custom visualizations of the information in the metadata. We make a separate matrix called `qc_data` and sorting it based on the `percent.mt` column. Then we make our own ggplot and specify that the x and y axes should be `nCount_RNA` and `nFeature_RNA` and that the points should be colored based on `percent.mt`. Then, use `scale_color_gradientn` to specify how the points should be colored, specifying that the limit should be between 0 and 10 and that we should `squish` anything that is out of bounds (effectively making our limits 0 and >10).
```{r}

qc_data <- all_data@meta.data[c('orig.ident','nCount_RNA','nFeature_RNA','percent.mt')] %>% arrange(percent.mt)

ggplot2::ggplot(qc_data, ggplot2::aes(x = nCount_RNA, y = nFeature_RNA, color = percent.mt)) + 
  ggplot2::geom_point() + 
 ggplot2:: scale_color_gradientn(colors = rev(brewer.pal(5, "Spectral")), limits = c(0,10), oob = (scales::squish)) +
  ggplot2::facet_wrap(~orig.ident) + 
  ggplot2::theme_bw()

```

- Low quality cells or empty droplets might have very few genes (`nFeatures`)
- Dead or dying cells will also have high mitochondrial reads (`percent.mt`)
- Doublets or multiplets will have high gene counts (`nFeatures`)
- The total number of molecules (`nCount`) detected in a cell corresponds with the number of genes (`nFeatures`)
- Most of the cells have less than 2000 genes and less than 7000 or so UMIs.
- Very low mitochondrial counts from the `ifnb` data and the nFeature_RNA scatter plots look strange -- perhaps this dataset was pre-filtered before being packaged into SeuratData.
- In the `pbmc3k` data, we can see groups of cells with high mitochondrial counts, low UMI counts, and lower numbers of genes.
- Our goal in QC filtering is to retain as much useful information as we can, while removing doublets, empty droplets, and dead cells.
- We will pick some thresholds for filtering based off of what we see in our data, keeping in mind that if you are doing this with your own data, your plots will probably look a bit different.

## Data Filtering

- Let's filter our data using `subset`, we'll keep cells that have between 500 and 7000 nFeature_RNA (genes) and less than 5% mitochondrial reads.

```{r}
all_data_sub <- subset(all_data, subset = nFeature_RNA > 500 & nFeature_RNA < 7000 & percent.mt < 5)
```

- You can re-examine your QC plots after filtering if you'd like:
```{r}
qc_data_sub <- all_data_sub@meta.data[c('orig.ident','nCount_RNA','nFeature_RNA','percent.mt')] %>% arrange(percent.mt)

ggplot2::ggplot(qc_data_sub,ggplot2:: aes(x = nCount_RNA, y = nFeature_RNA, color = percent.mt)) + 
  ggplot2::geom_point() + 
  ggplot2::scale_color_gradientn(colors = rev(brewer.pal(5, "Spectral")), limits = c(0,10), oob = (scales::squish)) +
  ggplot2::facet_wrap(~orig.ident) + 
  ggplot2::theme_bw()
```

- We can also take a look at how many cells we lost from filtering (245 cells lost from `pbmc3k`).
```{r}
table(all_data@meta.data$orig.ident)
table(all_data_sub@meta.data$orig.ident)

```